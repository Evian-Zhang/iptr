use std::{
    fs::File,
    path::{Path, PathBuf},
};

use super::ReadMemory;
use iptr_perf_pt_reader::PerfMmap2Header;
use memmap2::{Mmap, MmapOptions};
use thiserror::Error;

pub struct PerfMmapBasedMemoryReader {
    entries: Vec<MmapedEntry>,
}

pub struct MmapedEntry {
    mmap: Mmap,
    virtual_address: u64,
}

impl MmapedEntry {
    #[must_use]
    pub fn content(&self) -> &[u8] {
        &self.mmap
    }

    #[must_use]
    pub fn virtual_address(&self) -> u64 {
        self.virtual_address
    }
}

#[derive(Debug, Error)]
pub enum PerfMmapBasedMemoryReaderError {
    #[error("Not mmaped area {0:#x} accessed")]
    NotMmaped(u64),
}

#[derive(Debug, Error)]
pub enum PerfMmapBasedMemoryReaderCreateError {
    #[error("Failed to open mmaped file {}: {source}", path.display())]
    FileIo {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },
    #[error("Target file {} is shorter than mapped moment: expected {expect_length} bytes, but got {real_length} bytes.", path.display())]
    FileTooShort {
        path: PathBuf,
        expect_length: u64,
        real_length: u64,
    },
}

impl PerfMmapBasedMemoryReader {
    /// Create a memory reader from mmap2 headers in perf.data.
    ///
    /// For headers that lead to errors, an error log will be printed,
    /// and that header will be skipped instead of directly return error.
    ///
    /// To create a memory reader from perf.data, you should make sure
    /// that all binary images involved in the process that be recorded
    /// into perf.data are not modified and still in their original paths
    /// (perf.data only records the mmap operation for the target process,
    /// we use the arguments of mmap to reconstruct the target memory)
    #[expect(clippy::cast_possible_truncation)]
    pub fn new(
        mmap2_headers: &[PerfMmap2Header],
    ) -> Result<Self, PerfMmapBasedMemoryReaderCreateError> {
        let mut entries = Vec::with_capacity(mmap2_headers.len());

        for mmap2_header in mmap2_headers {
            let filename_path = Path::new(&mmap2_header.filename);
            if !filename_path.is_absolute() {
                log::warn!(
                    "Mmaped filename {} is not absolute path, skip.",
                    mmap2_header.filename
                );
                continue;
            }
            let file = File::open(filename_path).map_err(|io_err| {
                PerfMmapBasedMemoryReaderCreateError::FileIo {
                    path: filename_path.to_path_buf(),
                    source: io_err,
                }
            })?;
            // SAFETY: check the safety requirements of memmap2 documentation
            let mmap_res = unsafe {
                MmapOptions::default()
                    .len(mmap2_header.len as usize)
                    .offset(mmap2_header.pgoff)
                    .map(&file)
            };
            let mmap = mmap_res.map_err(|io_err| PerfMmapBasedMemoryReaderCreateError::FileIo {
                path: filename_path.to_path_buf(),
                source: io_err,
            })?;
            if mmap.len() as u64 != mmap2_header.len {
                return Err(PerfMmapBasedMemoryReaderCreateError::FileTooShort {
                    path: filename_path.to_path_buf(),
                    expect_length: mmap2_header.len,
                    real_length: mmap.len() as u64,
                });
            }
            log::trace!(
                "Mmaped {:016x}--{:016x}\t{}",
                mmap2_header.addr,
                mmap2_header.addr.saturating_add(mmap2_header.len),
                mmap2_header.filename
            );
            entries.push(MmapedEntry {
                mmap,
                virtual_address: mmap2_header.addr,
            });
        }

        entries.sort_by_key(|entry| entry.virtual_address);

        Ok(Self { entries })
    }

    /// Get mmaped entries.
    ///
    /// The entries are guaranteed to be sorted by virtual addresses
    #[must_use]
    pub fn mmapped_entries(&self) -> &[MmapedEntry] {
        &self.entries
    }
}

impl ReadMemory for PerfMmapBasedMemoryReader {
    type Error = PerfMmapBasedMemoryReaderError;

    fn at_decode_begin(&mut self) -> Result<(), Self::Error> {
        Ok(())
    }

    #[expect(clippy::cast_possible_truncation)]
    fn read_memory<T>(
        &mut self,
        address: u64,
        size: usize,
        callback: impl FnOnce(&[u8]) -> T,
    ) -> std::result::Result<T, Self::Error> {
        let pos = match self
            .entries
            .binary_search_by_key(&address, |entry| entry.virtual_address)
        {
            Ok(pos) => pos,
            Err(pos) => {
                if pos == 0 {
                    return Err(PerfMmapBasedMemoryReaderError::NotMmaped(address));
                }
                pos - 1
            }
        };
        // SAFETY: pos is generated by binary search, no possibility to out of bounds
        debug_assert!(pos < self.entries.len(), "Unexpected pos out of bounds!");
        let entry = unsafe { self.entries.get_unchecked(pos) };
        let start_offset = address - entry.virtual_address;
        let read_size = std::cmp::min(size, entry.mmap.len().saturating_sub(start_offset as usize));
        if read_size == 0 {
            return Err(PerfMmapBasedMemoryReaderError::NotMmaped(address));
        }
        let Some(mem) = entry
            .mmap
            .get((start_offset as usize)..((start_offset as usize).saturating_add(read_size)))
        else {
            return Err(PerfMmapBasedMemoryReaderError::NotMmaped(
                address.saturating_add(read_size as u64) - 1,
            ));
        };
        Ok(callback(mem))
    }
}
