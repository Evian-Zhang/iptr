use std::{fs::File, io::Read, path::Path};

use super::ReadMemory;
use memmap2::Mmap;
use thiserror::Error;

const PAGE_CACHE_ADDR_LINE_SIZE: u64 = 8;
const PAGE_SIZE: usize = 0x1000;

pub struct LibxdcMemoryReader {
    pages: Mmap,
    page_maps: Vec<(u64, usize)>,
}

#[derive(Debug, Error)]
pub enum LibxdcMemoryReaderCreateError {
    #[error("Failed to open page dump file")]
    InvalidPageDumpFile(#[source] std::io::Error),
    #[error("Failed to open page addr file")]
    InvalidPageAddrFile(#[source] std::io::Error),
    #[error("Size of page address file is not consistent with page dump file")]
    InconsistentLength,
}

impl LibxdcMemoryReader {
    pub fn new(page_dump: &Path, page_addr: &Path) -> Result<Self, LibxdcMemoryReaderCreateError> {
        let page_dump_file =
            File::open(page_dump).map_err(LibxdcMemoryReaderCreateError::InvalidPageDumpFile)?;
        let mut page_addr_file =
            File::open(page_addr).map_err(LibxdcMemoryReaderCreateError::InvalidPageAddrFile)?;
        let page_addr_file_len = page_addr_file
            .metadata()
            .map_err(LibxdcMemoryReaderCreateError::InvalidPageAddrFile)?
            .len();
        let num_pages = page_addr_file_len / PAGE_CACHE_ADDR_LINE_SIZE;
        let page_dump_file_len = page_dump_file
            .metadata()
            .map_err(LibxdcMemoryReaderCreateError::InvalidPageDumpFile)?
            .len();
        if num_pages * PAGE_SIZE as u64 != page_dump_file_len {
            return Err(LibxdcMemoryReaderCreateError::InconsistentLength);
        }

        let mut page_maps = Vec::with_capacity(num_pages as usize);
        let pages = unsafe {
            Mmap::map(&page_dump_file)
                .map_err(LibxdcMemoryReaderCreateError::InvalidPageDumpFile)?
        };
        let mut addr_buf = [0u8; 8];
        let mut offset = 0;
        while page_addr_file.read_exact(&mut addr_buf).is_ok() {
            let addr = u64::from_le_bytes(addr_buf);
            page_maps.push((addr & 0xFFFF_FFFF_FFFF_F000, offset));
            offset += PAGE_SIZE;
        }
        page_maps.sort_by_key(|(addr, _)| *addr);

        Ok(Self { pages, page_maps })
    }
}

#[derive(Debug, Error)]
pub enum LibxdcMemoryReaderError {
    #[error("Not mmaped area {0:#x} accessed")]
    NotMmaped(u64),
}

impl ReadMemory for LibxdcMemoryReader {
    type Error = LibxdcMemoryReaderError;

    fn at_decode_begin(&mut self) -> std::result::Result<(), Self::Error> {
        Ok(())
    }

    #[expect(clippy::cast_possible_truncation)]
    fn read_memory<T>(
        &mut self,
        address: u64,
        size: usize,
        callback: impl FnOnce(&[u8]) -> T,
    ) -> std::result::Result<T, Self::Error> {
        let pos = match self
            .page_maps
            .binary_search_by_key(&address, |(addr, _)| *addr)
        {
            Ok(pos) => pos,
            Err(pos) => {
                if pos == 0 {
                    return Err(LibxdcMemoryReaderError::NotMmaped(address));
                }
                pos - 1
            }
        };
        // SAFETY: pos is generated by binary search, no possibility to out of bounds
        debug_assert!(pos < self.page_maps.len(), "Unexpected pos out of bounds!");
        let (page_addr, offset) = unsafe { self.page_maps.get_unchecked(pos) };
        let page_content_start = *offset;
        let start_offset = address - page_addr;
        let read_size = std::cmp::min(size, PAGE_SIZE.saturating_sub(start_offset as usize));
        if read_size == 0 {
            // This includes cases where address - page_addr > PAGE_SIZE
            return Err(LibxdcMemoryReaderError::NotMmaped(address));
        }
        let content_start = page_content_start + start_offset as usize;
        let Some(mem) = self
            .pages
            .get(content_start..(content_start.saturating_add(read_size)))
        else {
            return Err(LibxdcMemoryReaderError::NotMmaped(
                address.saturating_add(read_size as u64) - 1,
            ));
        };
        Ok(callback(mem))
    }
}
