use std::{fs::File, path::PathBuf};

use anyhow::Context;
use clap::{Parser, ValueEnum};
use iptr_decoder::{DecodeOptions, packet_handler::log::PacketHandlerRawLogger};

/// Decode target intel PT packets in the low level and logs all details.
///
/// Set the environment variable `RUST_LOG=trace` for logging.
#[derive(Parser)]
struct Cmdline {
    /// Path of intel PT trace
    #[arg(short, long)]
    input: PathBuf,
    /// Input file format. Default is pure Intel PT
    #[arg(short, long, value_enum)]
    format: Option<FileFormat>,
}

/// Format of input file
#[derive(ValueEnum, Clone, Copy, Default)]
enum FileFormat {
    /// Pure Intel PT record traces
    #[default]
    IntelPt,
    /// perf.data generated by perf with intel-pt
    PerfData,
}

fn main() -> anyhow::Result<()> {
    env_logger::init();

    let Cmdline { input, format } = Cmdline::parse();

    let file = File::open(input).context("Failed to open input file")?;
    // SAFETY: check the safety requirements of memmap2 documentation
    let buf = unsafe { memmap2::Mmap::map(&file).context("Failed to mmap input file")? };

    let mut packet_handler = PacketHandlerRawLogger {};

    match format.unwrap_or(FileFormat::default()) {
        FileFormat::IntelPt => {
            iptr_decoder::decode(&buf, DecodeOptions::default(), &mut packet_handler)?;
        }
        FileFormat::PerfData => {
            let pt_auxtraces = iptr_perf_pt_reader::extract_pt_auxtraces(&buf)
                .context("Failed to parse perf.data format")?;
            for pt_auxtrace in pt_auxtraces {
                log::trace!("============================================");
                log::trace!("For Intel PT AUXTRACE with index {}", pt_auxtrace.idx);
                iptr_decoder::decode(
                    pt_auxtrace.auxtrace_data,
                    DecodeOptions::default(),
                    &mut packet_handler,
                )?;
            }
        }
    }

    Ok(())
}
