use std::{fs::File, io::Read, path::Path};

use anyhow::{Context, Result};
use iptr_edge_analyzer::ReadMemory;
use memmap2::Mmap;
use thiserror::Error;

const PAGE_CACHE_ADDR_LINE_SIZE: u64 = 8;
const PAGE_SIZE: usize = 0x1000;

pub struct MemoryReader {
    pages: Mmap,
    page_maps: Vec<(u64, usize)>,
}

impl MemoryReader {
    pub fn new(page_dump: &Path, page_addr: &Path) -> Result<Self> {
        let page_dump_file = File::open(page_dump).context("Failed to open page dump file")?;
        let mut page_addr_file = File::open(page_addr).context("Failed to open page addr file")?;
        let page_addr_file_len = page_addr_file.metadata()?.len();
        let num_pages = page_addr_file_len / PAGE_CACHE_ADDR_LINE_SIZE;
        let page_dump_file_len = page_dump_file.metadata()?.len();
        if num_pages * PAGE_SIZE as u64 != page_dump_file_len {
            return Err(anyhow::anyhow!(
                "Inconsistent page dump and page addr length"
            ));
        }

        let mut page_maps = Vec::with_capacity(num_pages as usize);
        let pages = unsafe { Mmap::map(&page_dump_file)? };
        let mut addr_buf = [0u8; 8];
        let mut offset = 0;
        while page_addr_file.read_exact(&mut addr_buf).is_ok() {
            let addr = u64::from_le_bytes(addr_buf);
            page_maps.push((addr & 0xFFFF_FFFF_FFFF_F000, offset));
            offset += PAGE_SIZE;
        }
        page_maps.sort_by_key(|(addr, _)| *addr);

        Ok(Self { pages, page_maps })
    }
}

#[derive(Debug, Error)]
pub enum MemoryReaderError {
    #[error("Not mmaped area {0:#x} accessed")]
    NotMmaped(u64),
}

impl ReadMemory for MemoryReader {
    type Error = MemoryReaderError;

    #[expect(clippy::cast_possible_truncation)]
    fn read_memory<T>(
        &mut self,
        address: u64,
        size: usize,
        callback: impl FnOnce(&[u8]) -> T,
    ) -> std::result::Result<T, Self::Error> {
        let pos = match self
            .page_maps
            .binary_search_by_key(&address, |(addr, _)| *addr)
        {
            Ok(pos) => pos,
            Err(pos) => {
                if pos == 0 {
                    return Err(MemoryReaderError::NotMmaped(address));
                }
                pos - 1
            }
        };
        // SAFETY: pos is generated by binary search, no possibility to out of bounds
        debug_assert!(pos < self.page_maps.len(), "Unexpected pos out of bounds!");
        let (page_addr, offset) = unsafe { self.page_maps.get_unchecked(pos) };
        let page_content_start = *offset;
        let start_offset = address - page_addr;
        let read_size = std::cmp::min(size, PAGE_SIZE.saturating_sub(start_offset as usize));
        if read_size == 0 {
            // This includes cases where address - page_addr > PAGE_SIZE
            return Err(MemoryReaderError::NotMmaped(address));
        }
        let content_start = page_content_start + start_offset as usize;
        let Some(mem) = self
            .pages
            .get(content_start..(content_start.saturating_add(read_size)))
        else {
            return Err(MemoryReaderError::NotMmaped(
                address.saturating_add(read_size as u64) - 1,
            ));
        };
        Ok(callback(mem))
    }
}
