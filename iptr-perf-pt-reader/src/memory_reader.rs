use std::{fs::File, path::Path};

use crate::PerfMmap2Header;
use iptr_edge_analyzer::ReadMemory;
use memmap2::{Mmap, MmapOptions};
use thiserror::Error;

pub struct PerfMmapBasedMemoryReader {
    entries: Vec<MmapedEntry>,
}

struct MmapedEntry {
    mmap: Mmap,
    virtual_address: u64,
}

#[derive(Debug, Error)]
pub enum PerfMmapBasedMemoryReaderError {
    #[error("Not mmaped area {0:#x} accessed")]
    NotMmaped(u64),
}

impl PerfMmapBasedMemoryReader {
    #[expect(clippy::cast_possible_truncation)]
    #[must_use]
    pub fn new(mmap2_headers: &[PerfMmap2Header]) -> Self {
        let mut entries = Vec::with_capacity(mmap2_headers.len());

        for mmap2_header in mmap2_headers {
            let filename_path = Path::new(&mmap2_header.filename);
            if !filename_path.is_absolute() {
                log::warn!(
                    "Mmaped filename {} is not absolute path, skip.",
                    mmap2_header.filename
                );
                continue;
            }
            let Ok(file) = File::open(filename_path).inspect_err(|err| {
                log::error!(
                    "Failed to open mmaped file {}: {err:?}",
                    mmap2_header.filename
                );
            }) else {
                continue;
            };
            // SAFETY: check the safety requirements of memmap2 documentation
            let mmap_res = unsafe {
                MmapOptions::default()
                    .len(mmap2_header.len as usize)
                    .offset(mmap2_header.pgoff)
                    .map(&file)
            };
            let Ok(mmap) = mmap_res.inspect_err(|err| {
                log::error!("Failed to mmap file {}: {err:?}", mmap2_header.filename);
            }) else {
                continue;
            };
            if mmap.len() != mmap2_header.len as usize {
                log::error!("Mismatched mmap length for {}.", mmap2_header.filename);
                continue;
            }
            log::trace!(
                "Mmaped {:016x}--{:016x}\t{}",
                mmap2_header.addr,
                mmap2_header.addr.saturating_add(mmap2_header.len),
                mmap2_header.filename
            );
            entries.push(MmapedEntry {
                mmap,
                virtual_address: mmap2_header.addr,
            });
        }

        entries.sort_by_key(|entry| entry.virtual_address);

        Self { entries }
    }
}

impl ReadMemory for PerfMmapBasedMemoryReader {
    type Error = PerfMmapBasedMemoryReaderError;

    #[expect(clippy::cast_possible_truncation)]
    fn read_memory<T>(
        &mut self,
        address: u64,
        size: usize,
        callback: impl FnOnce(&[u8]) -> T,
    ) -> std::result::Result<T, Self::Error> {
        let pos = match self
            .entries
            .binary_search_by_key(&address, |entry| entry.virtual_address)
        {
            Ok(pos) => pos,
            Err(pos) => {
                if pos == 0 {
                    return Err(PerfMmapBasedMemoryReaderError::NotMmaped(address));
                }
                pos - 1
            }
        };
        // SAFETY: pos is generated by binary search, no possibility to out of bounds
        debug_assert!(pos < self.entries.len(), "Unexpected pos out of bounds!");
        let entry = unsafe { self.entries.get_unchecked(pos) };
        let start_offset = address - entry.virtual_address;
        let read_size = std::cmp::min(size, entry.mmap.len().saturating_sub(start_offset as usize));
        if read_size == 0 {
            return Err(PerfMmapBasedMemoryReaderError::NotMmaped(address));
        }
        let Some(mem) = entry
            .mmap
            .get((start_offset as usize)..((start_offset as usize).saturating_add(read_size)))
        else {
            return Err(PerfMmapBasedMemoryReaderError::NotMmaped(
                address.saturating_add(read_size as u64) - 1,
            ));
        };
        Ok(callback(mem))
    }
}
